<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">

    
      <!-- Google Tag Manager -->
      <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
      new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
      })(window,document,'script','dataLayer','GTM-PNFDVBB');</script>
      <!-- End Google Tag Manager -->
    

    <!-- Basic -->
    <title>Implementing directives | Apollo Server</title>
    <meta name="description" content="Implementing custom directives to transform schema types, fields, and arguments">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
      <link rel="shortcut icon" type="image/png" href="../images/favicon-apollo.png" sizes="16x16 32x32 64x64">
    

    <!-- Social -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://www.apollographql.com/docs/apollo-server">
    <meta property="og:title" content="Implementing directives | Apollo Server">
    <meta property="og:description" content="Implementing custom directives to transform schema types, fields, and arguments">
    <meta property="og:image" content="">
    <meta name="twitter:site" content="@apollographql">
    <meta name="twitter:title" content="Implementing directives | Apollo Server">
    <meta name="twitter:description" content="Implementing custom directives to transform schema types, fields, and arguments">
    <meta name="twitter:image" content="">

    <!-- Misc -->
    <meta name="google-site-verification" content="">

    
    
    <link href="//cdn.jsdelivr.net/npm/prismjs@1.15.0/themes/prism.min.css" rel="stylesheet" type="text/css">
    <link href="//cdn.jsdelivr.net/npm/prismjs@1.15.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" type="text/css">
    <link href="//cdn.jsdelivr.net/npm/prismjs@1.15.0/plugins/line-highlight/prism-line-highlight.css" rel="stylesheet" type="text/css">

    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300,200,300italic,400italic" rel="stylesheet" type="text/css">
    
      <link rel="stylesheet" href="../style/bundle-apollo.css">
    
    <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.css">
  </head>
  <body class="">
    
      <!-- Google Tag Manager (noscript) -->
      <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PNFDVBB" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
      <!-- End Google Tag Manager (noscript) -->
    
      

  <div class="nav sunset">
    <div class="nav-group left">
      <div class="nav-item mobile-button js-sidebar-toggle show-mobile">
        <span class="icon-menu"></span>
      </div>
      <div class="nav-item">
        
        <a class="logo-wrapper" href="https://www.apollographql.com/" title="Apollo ">
          <img src="../images/logo-apollo-space-left.svg" alt="Apollo" class="logo">
          
            <span></span>
          
        </a>
      </div>
    </div>


    
      <div class="nav-group right">
        <div id="nav-container" class="show-desktop"></div>
        <script src="https://apollographql-nav.netlify.com/index.js"></script>
        <script>ApolloNav.initNav({ theme: 'light' }, 'nav-container')</script>
      </div>
    
    </div>
  

  

<div class="sidebar charcoal">
  <div class="panel">
    
      <div id="sidebar-panel-nav"></div>
      <script>ApolloNav.initNav({ theme: 'light', id: 'mobile-nav' }, 'sidebar-panel-nav')</script>
    
  </div>

  <div class="sidebar-content">
    <div class="topcap">
      <span class="title-sidebar">Apollo Server</span>
      
        <span class="select version-sidebar nochrome">
          <select class="version-select">
            
              <option value="v2">2</option>
            
              <option value="v1">1</option>
            
          </select>
        </span>
      
    </div>

    
    <div class="wrapper-search">
      <div class="input-area">
        <div class="input-symbol small round">
          <input type="text" placeholder="Search Apollo Server" id="desktop-search-input">
          <span class="icon-search"></span>
        </div>
      </div>
      <div class="wrapper-desktop-search-results"></div>
    </div>

    

    <ul class="toc">
      

        <li>
          

          <ul class="list-toc">
            
              
              
              <li class="item-toc ">
                <a href="../." class="sidebar-link ">
                  <span>Introduction</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="../getting-started.html" class="sidebar-link ">
                  <span>Getting started</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="../whats-new.html" class="sidebar-link ">
                  <span>What's new?</span>
                </a>
              </li>
              
            
          </ul>
        </li>

        <hr>
      

        <li>
          
            <div class="heading-toc">Essentials</div>
          

          <ul class="list-toc">
            
              
              
              <li class="item-toc ">
                <a href="../essentials/schema.html" class="sidebar-link ">
                  <span>Writing a schema</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="../essentials/server.html" class="sidebar-link ">
                  <span>Building a server</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="../essentials/data.html" class="sidebar-link ">
                  <span>Fetching data with resolvers</span>
                </a>
              </li>
              
            
          </ul>
        </li>

        <hr>
      

        <li>
          
            <div class="heading-toc">Features</div>
          

          <ul class="list-toc">
            
              
              
              <li class="item-toc ">
                <a href="mocking.html" class="sidebar-link ">
                  <span>Mocking</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="errors.html" class="sidebar-link ">
                  <span>Error handling</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="data-sources.html" class="sidebar-link ">
                  <span>Data sources</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="subscriptions.html" class="sidebar-link ">
                  <span>Subscriptions</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="metrics.html" class="sidebar-link ">
                  <span>Monitoring and metrics</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="graphql-playground.html" class="sidebar-link ">
                  <span>GraphQL Playground</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="scalars-enums.html" class="sidebar-link ">
                  <span>Custom scalars and enums</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="unions-interfaces.html" class="sidebar-link ">
                  <span>Unions and interfaces</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="directives.html" class="sidebar-link ">
                  <span>Using schema directives</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc current">
                <a href="" class="sidebar-link current">
                  <span>Implementing directives</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="authentication.html" class="sidebar-link ">
                  <span>Authentication</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="testing.html" class="sidebar-link ">
                  <span>Integration testing</span>
                </a>
              </li>
              
            
          </ul>
        </li>

        <hr>
      

        <li>
          
            <div class="heading-toc">Deployment</div>
          

          <ul class="list-toc">
            
              
              
              <li class="item-toc ">
                <a href="../deployment/heroku.html" class="sidebar-link ">
                  <span>Heroku</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="../deployment/lambda.html" class="sidebar-link ">
                  <span>Lambda</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="../deployment/now.html" class="sidebar-link ">
                  <span>Now</span>
                </a>
              </li>
              
            
          </ul>
        </li>

        <hr>
      

        <li>
          
            <div class="heading-toc">API Reference</div>
          

          <ul class="list-toc">
            
              
              
              <li class="item-toc ">
                <a href="../api/apollo-server.html" class="sidebar-link ">
                  <span>apollo-server</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="../api/graphql-tools.html" class="sidebar-link ">
                  <span>graphql-tools</span>
                </a>
              </li>
              
            
          </ul>
        </li>

        <hr>
      

        <li>
          
            <div class="heading-toc">Migration</div>
          

          <ul class="list-toc">
            
              
              
              <li class="item-toc ">
                <a href="../migration-two-dot.html" class="sidebar-link ">
                  <span>Migrating to v2.0</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="../migration-engine.html" class="sidebar-link ">
                  <span>Using Engine with v2.0</span>
                </a>
              </li>
              
            
              
              
              <li class="item-toc ">
                <a href="../migration-file-uploads.html" class="sidebar-link ">
                  <span>File uploads in Node.js < v8.5.0</span>
                </a>
              </li>
              
            
          </ul>
        </li>

        <hr>
      
    </ul>
  </div>
</div>

    <div class="content">

      <div class="header-content">
        <div class="header-wrapper">
          <div class="title-wrapper">
            <h1 class="title-page">
              Implementing directives
            </h1>
            
              <div class="subtitle-page">
                Implementing custom directives to transform schema types, fields, and arguments
              </div>
              
          </div>
        </div>
      </div>

      <div class="content-wrapper">
        <div class="document-formatting">
          <p>Before learning how to implement schema directives, <a href="./directives.html">this section</a> will provide the necessary background on schema directives and their use.</p>
<h2 id="Implementing-schema-directives"><a href="#Implementing-schema-directives" class="headerlink" title="Implementing schema directives"></a>Implementing schema directives</h2><p>Since the GraphQL specification does not discuss any specific implementation strategy for directives, itâ€™s up to each GraphQL server framework to expose an API for implementing new directives.</p>
<p>If youâ€™re using Apollo Server, you are using the <a href="https://github.com/apollographql/graphql-tools" target="_blank" rel="noopener"><code>graphql-tools</code></a> npm package, which provides a convenient yet powerful tool for implementing directive syntax: the <a href="https://github.com/apollographql/graphql-tools/blob/wip-schema-directives/src/schemaVisitor.ts" target="_blank" rel="noopener"><code>SchemaDirectiveVisitor</code></a> class.</p>
<p>To implement a schema directive using <code>SchemaDirectiveVisitor</code>, simply create a subclass of <code>SchemaDirectiveVisitor</code> that overrides one or more of the following visitor methods:</p>
<ul>
<li><code>visitSchema(schema: GraphQLSchema)</code></li>
<li><code>visitScalar(scalar: GraphQLScalarType)</code></li>
<li><code>visitObject(object: GraphQLObjectType)</code></li>
<li><code>visitFieldDefinition(field: GraphQLField&lt;any, any&gt;)</code></li>
<li><code>visitArgumentDefinition(argument: GraphQLArgument)</code></li>
<li><code>visitInterface(iface: GraphQLInterfaceType)</code></li>
<li><code>visitUnion(union: GraphQLUnionType)</code></li>
<li><code>visitEnum(type: GraphQLEnumType)</code></li>
<li><code>visitEnumValue(value: GraphQLEnumValue)</code></li>
<li><code>visitInputObject(object: GraphQLInputObjectType)</code></li>
<li><code>visitInputFieldDefinition(field: GraphQLInputField)</code></li>
</ul>
<p>By overriding methods like <code>visitObject</code>, a subclass of <code>SchemaDirectiveVisitor</code> expresses interest in certain schema types such as <code>GraphQLObjectType</code> (the first parameter type of <code>visitObject</code>).</p>
<p>These method names correspond to all possible <a href="https://github.com/graphql/graphql-js/blob/a62eea88d5844a3bd9725c0f3c30950a78727f3e/src/language/directiveLocation.js#L22-L33" target="_blank" rel="noopener">locations</a> where a directive may be used in a schema. For example, the location <code>INPUT_FIELD_DEFINITION</code> is handled by <code>visitInputFieldDefinition</code>.</p>
<p>Here is one possible implementation of the <code>@deprecated</code> directive we saw above:</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-js">const { SchemaDirectiveVisitor } = require(&quot;apollo-server&quot;);

class DeprecatedDirective extends SchemaDirectiveVisitor {
  public visitFieldDefinition(field: GraphQLField&lt;any, any&gt;) {
    field.isDeprecated = true;
    field.deprecationReason = this.args.reason;
  }

  public visitEnumValue(value: GraphQLEnumValue) {
    value.isDeprecated = true;
    value.deprecationReason = this.args.reason;
  }
}
</code></pre>
<p>In order to apply this implementation to a schema that contains <code>@deprecated</code> directives, simply pass the <code>DeprecatedDirective</code> class to Apollo Serverâ€™s constructor via the <code>schemaDirectives</code> option:</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-js">const { ApolloServer, gql } = require(&quot;apollo-server&quot;);

const typeDefs = gql`
  type ExampleType {
    newField: String
    oldField: String @deprecated(reason: &quot;Use \`newField\`.&quot;)
  }
`;

const server = new ApolloServer({
  typeDefs,
  resolvers,
  schemaDirectives: {
    deprecated: DeprecatedDirective
  }
});

server.listen().then(({ url }) =&gt; {
  console.log(`ðŸš€ Server ready at ${url}`);
});
</code></pre>
<p>Alternatively, if you want to modify an existing schema object, you can use the <code>SchemaDirectiveVisitor.visitSchemaDirectives</code> interface directly:</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-js">SchemaDirectiveVisitor.visitSchemaDirectives(schema, {
  deprecated: DeprecatedDirective
});
</code></pre>
<p>Note that a subclass of <code>SchemaDirectiveVisitor</code> may be instantiated multiple times to visit multiple different occurrences of the <code>@deprecated</code> directive. Thatâ€™s why you provide a class rather than an instance of that class.</p>
<p>If for some reason you have a schema that uses another name for the <code>@deprecated</code> directive, but you want to use the same implementation, you can! The same <code>DeprecatedDirective</code> class can be passed with a different name, simply by changing its key in the <code>schemaDirectives</code> object passed to the Apollo Server constructor. In other words, <code>SchemaDirectiveVisitor</code> implementations are effectively anonymous, so itâ€™s up to whoever uses them to assign names to them.</p>
<h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>To appreciate the range of possibilities enabled by <code>SchemaDirectiveVisitor</code>, letâ€™s examine a variety of practical examples.</p>
<h3 id="Uppercasing-strings"><a href="#Uppercasing-strings" class="headerlink" title="Uppercasing strings"></a>Uppercasing strings</h3><p>Suppose you want to ensure a string-valued field is converted to uppercase. Though this use case is simple, itâ€™s a good example of a directive implementation that works by wrapping a fieldâ€™s <code>resolve</code> function:</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-js">const { ApolloServer, gql, SchemaDirectiveVisitor } = require(&quot;apollo-server&quot;);
const { defaultFieldResolver } = require(&quot;graphql&quot;);

const typeDefs = gql`
  directive @upper on FIELD_DEFINITION

  type Query {
    hello: String @upper
  }
`;

class UpperCaseDirective extends SchemaDirectiveVisitor {
  visitFieldDefinition(field) {
    const { resolve = defaultFieldResolver } = field;
    field.resolve = async function (...args) {
      const result = await resolve.apply(this, args);
      if (typeof result === &quot;string&quot;) {
        return result.toUpperCase();
      }
      return result;
    };
  }
}

const server = new ApolloServer({
  typeDefs,
  schemaDirectives: {
    upper: UpperCaseDirective,
    upperCase: UpperCaseDirective
  }
});

server.listen().then(({ url }) =&gt; {
  console.log(`ðŸš€ Server ready at ${url}`);
});
</code></pre>
<p>Notice how easy it is to handle both <code>@upper</code> and <code>@upperCase</code> with the same <code>UpperCaseDirective</code> implementation.</p>
<h3 id="Fetching-data-from-a-REST-API"><a href="#Fetching-data-from-a-REST-API" class="headerlink" title="Fetching data from a REST API"></a>Fetching data from a REST API</h3><p>Suppose youâ€™ve defined an object type that corresponds to a <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="noopener">REST</a> resource, and you want to avoid implementing resolver functions for every field:</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-js">const { ApolloServer, gql, SchemaDirectiveVisitor } = require(&quot;apollo-server&quot;);

const typeDefs = gql`
  directive @rest(url: String) on FIELD_DEFINITION

  type Query {
    people: [Person] @rest(url: &quot;&#x2F;api&#x2F;v1&#x2F;people&quot;)
  }
`;

class RestDirective extends SchemaDirectiveVisitor {
  public visitFieldDefinition(field) {
    const { url } = this.args;
    field.resolve = () =&gt; fetch(url);
  }
}

const server = new ApolloServer({
  typeDefs,
  schemaDirectives: {
    rest: RestDirective
  }
});

server.listen().then(({ url }) =&gt; {
  console.log(`ðŸš€ Server ready at ${url}`);
});
</code></pre>
<p>There are many more issues to consider when implementing a real GraphQL wrapper over a REST endpoint (such as how to do caching or pagination), but this example demonstrates the basic structure.</p>
<h3 id="Formatting-date-strings"><a href="#Formatting-date-strings" class="headerlink" title="Formatting date strings"></a>Formatting date strings</h3><p>Suppose your resolver returns a <code>Date</code> object but you want to return a formatted string to the client:</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-js">const { ApolloServer, gql, SchemaDirectiveVisitor } = require(&quot;apollo-server&quot;);

const typeDefs = gql`
  directive @date(format: String) on FIELD_DEFINITION

  scalar Date

  type Post {
    published: Date @date(format: &quot;mmmm d, yyyy&quot;)
  }
`;

class DateFormatDirective extends SchemaDirectiveVisitor {
  visitFieldDefinition(field) {
    const { resolve = defaultFieldResolver } = field;
    const { format } = this.args;
    field.resolve = async function (...args) {
      const date = await resolve.apply(this, args);
      return require(&#39;dateformat&#39;)(date, format);
    };
    &#x2F;&#x2F; The formatted Date becomes a String, so the field type must change:
    field.type = GraphQLString;
  }
}

const server = new ApolloServer({
  typeDefs,
  schemaDirectives: {
    date: DateFormatDirective
  }
});

server.listen().then(({ url }) =&gt; {
  console.log(`ðŸš€ Server ready at ${url}`);
});
</code></pre>
<p>Of course, it would be even better if the schema author did not have decide on a specific <code>Date</code> format, but could instead leave that decision to the client. To make this work, the directive just needs to add an additional argument to the field:</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-js">const { ApolloServer, gql, SchemaDirectiveVisitor } = require(&quot;apollo-server&quot;);
const formatDate = require(&quot;dateformat&quot;);
const { defaultFieldResolver, GraphQLString } = require(&quot;graphql&quot;);

const typeDefs = gql`
  directive @date(
    defaultFormat: String = &quot;mmmm d, yyyy&quot;
  ) on FIELD_DEFINITION

  scalar Date

  type Query {
    today: Date @date
  }
`;

class FormattableDateDirective extends SchemaDirectiveVisitor {
  public visitFieldDefinition(field) {
    const { resolve = defaultFieldResolver } = field;
    const { defaultFormat } = this.args;

    field.args.push({
      name: &#39;format&#39;,
      type: GraphQLString
    });

    field.resolve = async function (
      source,
      { format, ...otherArgs },
      context,
      info,
    ) {
      const date = await resolve.call(this, source, otherArgs, context, info);
      &#x2F;&#x2F; If a format argument was not provided, default to the optional
      &#x2F;&#x2F; defaultFormat argument taken by the @date directive:
      return formatDate(date, format || defaultFormat);
    };

    field.type = GraphQLString;
  }
}

const server = new ApolloServer({
  typeDefs,
  schemaDirectives: {
    date: FormattableDateDirective
  }
});

server.listen().then(({ url }) =&gt; {
  console.log(`ðŸš€ Server ready at ${url}`);
});
</code></pre>
<p>Now the client can specify a desired <code>format</code> argument when requesting the <code>Query.today</code> field, or omit the argument to use the <code>defaultFormat</code> string specified in the schema:</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-js">const { request } = require(&quot;graphql-request&quot;);

server.listen().then(({ url }) =&gt; {
  request(url, `query { today }`).then(result =&gt; {
    &#x2F;&#x2F; Logs with the default &quot;mmmm d, yyyy&quot; format:
    console.log(result.data.today);
  });

  request(url, `query {
    today(format: &quot;d mmm yyyy&quot;)
  }`).then(result =&gt; {
    &#x2F;&#x2F; Logs with the requested &quot;d mmm yyyy&quot; format:
    console.log(result.data.today);
  });
})
</code></pre>
<h3 id="Marking-strings-for-internationalization"><a href="#Marking-strings-for-internationalization" class="headerlink" title="Marking strings for internationalization"></a>Marking strings for internationalization</h3><p>Suppose you have a function called <code>translate</code> that takes a string, a path identifying that stringâ€™s role in your application, and a target locale for the translation.</p>
<p>Hereâ€™s how you might make sure <code>translate</code> is used to localize the <code>greeting</code> field of a <code>Query</code> type:</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-js">const { ApolloServer, gql, SchemaDirectiveVisitor } = require(&quot;apollo-server&quot;);

const typeDefs = gql`
  directive @intl on FIELD_DEFINITION

  type Query {
    greeting: String @intl
  }
`;

class IntlDirective extends SchemaDirectiveVisitor {
  visitFieldDefinition(field, details) {
    const { resolve = defaultFieldResolver } = field;
    field.resolve = async function (...args) {
      const context = args[2];
      const defaultText = await resolve.apply(this, args);
      &#x2F;&#x2F; In this example, path would be [&quot;Query&quot;, &quot;greeting&quot;]:
      const path = [details.objectType.name, field.name];
      return translate(defaultText, path, context.locale);
    };
  }
}

const server = new ApolloServer({
  typeDefs,
  schemaDirectives: {
    intl: IntlDirective
  }
});

server.listen().then(({ url }) =&gt; {
  console.log(`ðŸš€ Server ready at ${url}`);
});
</code></pre>
<p>GraphQL is great for internationalization, since a GraphQL server can access unlimited translation data, and clients can simply ask for the translations they need.</p>
<h3 id="Enforcing-access-permissions"><a href="#Enforcing-access-permissions" class="headerlink" title="Enforcing access permissions"></a>Enforcing access permissions</h3><p>Imagine a hypothetical <code>@auth</code> directive that takes an argument <code>requires</code> of type <code>Role</code>, which defaults to <code>ADMIN</code>. This <code>@auth</code> directive can appear on an <code>OBJECT</code> like <code>User</code> to set default access permissions for all <code>User</code> fields, as well as appearing on individual fields, to enforce field-specific <code>@auth</code> restrictions:</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-gql">directive @auth(
  requires: Role = ADMIN,
) on OBJECT | FIELD_DEFINITION

enum Role {
  ADMIN
  REVIEWER
  USER
  UNKNOWN
}

type User @auth(requires: USER) {
  name: String
  banned: Boolean @auth(requires: ADMIN)
  canPost: Boolean @auth(requires: REVIEWER)
}
</code></pre>
<p>What makes this example tricky is that the <code>OBJECT</code> version of the directive needs to wrap all fields of the object, even though some of those fields may be individually wrapped by <code>@auth</code> directives at the <code>FIELD_DEFINITION</code> level, and we would prefer not to rewrap resolvers if we can help it:</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-js">const { ApolloServer, gql, SchemaDirectiveVisitor } = require(&quot;apollo-server&quot;);

class AuthDirective extends SchemaDirectiveVisitor {
  visitObject(type) {
    this.ensureFieldsWrapped(type);
    type._requiredAuthRole = this.args.requires;
  }
  &#x2F;&#x2F; Visitor methods for nested types like fields and arguments
  &#x2F;&#x2F; also receive a details object that provides information about
  &#x2F;&#x2F; the parent and grandparent types.
  visitFieldDefinition(field, details) {
    this.ensureFieldsWrapped(details.objectType);
    field._requiredAuthRole = this.args.requires;
  }

  ensureFieldsWrapped(objectType) {
    &#x2F;&#x2F; Mark the GraphQLObjectType object to avoid re-wrapping:
    if (objectType._authFieldsWrapped) return;
    objectType._authFieldsWrapped = true;

    const fields = objectType.getFields();

    Object.keys(fields).forEach(fieldName =&gt; {
      const field = fields[fieldName];
      const { resolve = defaultFieldResolver } = field;
      field.resolve = async function (...args) {
        &#x2F;&#x2F; Get the required Role from the field first, falling back
        &#x2F;&#x2F; to the objectType if no Role is required by the field:
        const requiredRole =
          field._requiredAuthRole ||
          objectType._requiredAuthRole;

        if (! requiredRole) {
          return resolve.apply(this, args);
        }

        const context = args[2];
        const user = await getUser(context.headers.authToken);
        if (! user.hasRole(requiredRole)) {
          throw new Error(&quot;not authorized&quot;);
        }

        return resolve.apply(this, args);
      };
    });
  }
}

const server = new ApolloServer({
  typeDefs,
  schemaDirectives: {
    auth: AuthDirective,
    authorized: AuthDirective,
    authenticated: AuthDirective
  }
});

server.listen().then(({ url }) =&gt; {
  console.log(`ðŸš€ Server ready at ${url}`);
});
</code></pre>
<p>One drawback of this approach is that it does not guarantee fields will be wrapped if they are added to the schema after <code>AuthDirective</code> is applied, and the whole <code>getUser(context.headers.authToken)</code> is a made-up API that would need to be fleshed out. In other words, weâ€™ve glossed over some of the details that would be required for a production-ready implementation of this directive, though we hope the basic structure shown here inspires you to find clever solutions to the remaining problems.</p>
<h3 id="Enforcing-value-restrictions"><a href="#Enforcing-value-restrictions" class="headerlink" title="Enforcing value restrictions"></a>Enforcing value restrictions</h3><p>Suppose you want to enforce a maximum length for a string-valued field:</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-js">const { ApolloServer, gql, SchemaDirectiveVisitor } = require(&#39;apollo-server&#39;);
const { GraphQLScalarType, GraphQLNonNull } = require(&#39;graphql&#39;);

const typeDefs = gql`
  directive @length(max: Int) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

  type Query {
    books: [Book]
  }

  type Book {
    title: String @length(max: 50)
  }

  type Mutation {
    createBook(book: BookInput): Book
  }

  input BookInput {
    title: String! @length(max: 50)
  }
`;

class LengthDirective extends SchemaDirectiveVisitor {
  visitInputFieldDefinition(field) {
    this.wrapType(field);
  }

  visitFieldDefinition(field) {
    this.wrapType(field);
  }

  &#x2F;&#x2F; Replace field.type with a custom GraphQLScalarType that enforces the
  &#x2F;&#x2F; length restriction.
  wrapType(field) {
    if (
      field.type instanceof GraphQLNonNull &amp;&amp;
      field.type.ofType instanceof GraphQLScalarType
    ) {
      field.type = new GraphQLNonNull(
        new LimitedLengthType(field.type.ofType, this.args.max),
      );
    } else if (field.type instanceof GraphQLScalarType) {
      field.type = new LimitedLengthType(field.type, this.args.max);
    } else {
      throw new Error(`Not a scalar type: ${field.type}`);
    }
  }
}

class LimitedLengthType extends GraphQLScalarType {
  constructor(type, maxLength) {
    super({
      name: `LengthAtMost${maxLength}`,

      &#x2F;&#x2F; For more information about GraphQLScalar type (de)serialization,
      &#x2F;&#x2F; see the graphql-js implementation:
      &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;graphql&#x2F;graphql-js&#x2F;blob&#x2F;31ae8a8e8312&#x2F;src&#x2F;type&#x2F;definition.js#L425-L446

      serialize(value) {
        value = type.serialize(value);
        assert.isAtMost(value.length, maxLength);
        return value;
      },

      parseValue(value) {
        return type.parseValue(value);
      },

      parseLiteral(ast) {
        return type.parseLiteral(ast);
      },
    });
  }
}

const server = new ApolloServer({
  typeDefs,
  resolvers,
  schemaDirectives: {
    length: LengthDirective,
  },
});

server.listen().then(({ url }) =&gt; {
  console.log(`ðŸš€ Server ready at ${url}`);
});
</code></pre>
<h3 id="Synthesizing-unique-IDs"><a href="#Synthesizing-unique-IDs" class="headerlink" title="Synthesizing unique IDs"></a>Synthesizing unique IDs</h3><p>Suppose your database uses incrementing IDs for each resource type, so IDs are not unique across all resource types. Hereâ€™s how you might synthesize a field called <code>uid</code> that combines the object type with various field values to produce an ID thatâ€™s unique across your schema:</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-js">const { ApolloServer, gql, SchemaDirectiveVisitor } = require(&quot;apollo-server&quot;);
const { GraphQLID } = require(&quot;graphql&quot;);
const { createHash } = require(&quot;crypto&quot;);

const typeDefs = gql`
  directive @uniqueID(
    # The name of the new ID field, &quot;uid&quot; by default:
    name: String = &quot;uid&quot;

    # Which fields to include in the new ID:
    from: [String] = [&quot;id&quot;]
  ) on OBJECT

  # Since this type just uses the default values of name and from,
  # we don&#39;t have to pass any arguments to the directive:
  type Location @uniqueID {
    id: Int
    address: String
  }

  # This type uses both the person&#39;s name and the personID field,
  # in addition to the &quot;Person&quot; type name, to construct the ID:
  type Person @uniqueID(from: [&quot;name&quot;, &quot;personID&quot;]) {
    personID: Int
    name: String
  }
`;

class UniqueIdDirective extends SchemaDirectiveVisitor {
  visitObject(type) {
    const { name, from } = this.args;
    const fields = type.getFields();
    if (name in fields) {
      throw new Error(`Conflicting field name ${name}`);
    }
    fields[name] = {
      name,
      type: GraphQLID,
      description: &#39;Unique ID&#39;,
      args: [],
      resolve(object) {
        const hash = createHash(&quot;sha1&quot;);
        hash.update(type.name);
        from.forEach(fieldName =&gt; {
          hash.update(String(object[fieldName]));
        });
        return hash.digest(&quot;hex&quot;);
      }
    };
  }
}

const server = new ApolloServer({
  typeDefs,
  resolvers,
  schemaDirectives: {
    uniqueID: UniqueIdDirective
  }
});

server.listen().then(({ url }) =&gt; {
  console.log(`ðŸš€ Server ready at ${url}`);
});
</code></pre>
<h2 id="Declaring-schema-directives"><a href="#Declaring-schema-directives" class="headerlink" title="Declaring schema directives"></a>Declaring schema directives</h2><p>While the above examples should be sufficient to implement any <code>@directive</code> used in your schema, SDL syntax also supports declaring the names, argument types, default argument values, and permissible locations of any available directives:</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-js">directive @auth(
  requires: Role = ADMIN,
) on OBJECT | FIELD_DEFINITION

enum Role {
  ADMIN
  REVIEWER
  USER
  UNKNOWN
}

type User @auth(requires: USER) {
  name: String
  banned: Boolean @auth(requires: ADMIN)
  canPost: Boolean @auth(requires: REVIEWER)
}
</code></pre>
<p>This hypothetical <code>@auth</code> directive takes an argument named <code>requires</code> of type <code>Role</code>, which defaults to <code>ADMIN</code> if <code>@auth</code> is used without passing an explicit <code>requires</code> argument. The <code>@auth</code> directive can appear on an <code>OBJECT</code> like <code>User</code> to set a default access control for all <code>User</code> fields, and also on individual fields, to enforce field-specific <code>@auth</code> restrictions.</p>
<p>Enforcing the requirements of the declaration is something a <code>SchemaDirectiveVisitor</code> implementation could do itself, in theory, but the SDL syntax is easer to read and write, and provides value even if youâ€™re not using the <code>SchemaDirectiveVisitor</code> abstraction.</p>
<p>However, if youâ€™re implementing a reusable <code>SchemaDirectiveVisitor</code> for public consumption, you will probably not be the person writing the SDL syntax, so you may not have control over which directives the schema author decides to declare, and how. Thatâ€™s why a well-implemented, reusable <code>SchemaDirectiveVisitor</code> should consider overriding the <code>getDirectiveDeclaration</code> method:</p>

<!-- Has Prism -->
<pre class="line-numbers" style=""><code class="language-js">const { ApolloServer, gql, SchemaDirectiveVisitor } = require(&quot;apollo-server&quot;);
const { DirectiveLocation, GraphQLDirective, GraphQLEnumType } = require(&quot;graphql&quot;);

class AuthDirective extends SchemaDirectiveVisitor {
  public visitObject(object: GraphQLObjectType) {...}
  public visitFieldDefinition(field: GraphQLField&lt;any, any&gt;) {...}

  public static getDirectiveDeclaration(
    directiveName: string,
    schema: GraphQLSchema,
  ): GraphQLDirective {
    const previousDirective = schema.getDirective(directiveName);
    if (previousDirective) {
      &#x2F;&#x2F; If a previous directive declaration exists in the schema, it may be
      &#x2F;&#x2F; better to modify it than to return a new GraphQLDirective object.
      previousDirective.args.forEach(arg =&gt; {
        if (arg.name === &#39;requires&#39;) {
          &#x2F;&#x2F; Lower the default minimum Role from ADMIN to REVIEWER.
          arg.defaultValue = &#39;REVIEWER&#39;;
        }
      });

      return previousDirective;
    }

    &#x2F;&#x2F; If a previous directive with this name was not found in the schema,
    &#x2F;&#x2F; there are several options:
    &#x2F;&#x2F;
    &#x2F;&#x2F; 1. Construct a new GraphQLDirective (see below).
    &#x2F;&#x2F; 2. Throw an exception to force the client to declare the directive.
    &#x2F;&#x2F; 3. Return null, and forget about declaring this directive.
    &#x2F;&#x2F;
    &#x2F;&#x2F; All three are valid options, since the visitor will still work without
    &#x2F;&#x2F; any declared directives. In fact, unless you&#39;re publishing a directive
    &#x2F;&#x2F; implementation for public consumption, you can probably just ignore
    &#x2F;&#x2F; getDirectiveDeclaration altogether.

    return new GraphQLDirective({
      name: directiveName,
      locations: [
        DirectiveLocation.OBJECT,
        DirectiveLocation.FIELD_DEFINITION,
      ],
      args: {
        requires: {
          &#x2F;&#x2F; Having the schema available here is important for obtaining
          &#x2F;&#x2F; references to existing type objects, such as the Role enum.
          type: (schema.getType(&#39;Role&#39;) as GraphQLEnumType),
          &#x2F;&#x2F; Set the default minimum Role to REVIEWER.
          defaultValue: &#39;REVIEWER&#39;,
        }
      }]
    });
  }
}
</code></pre>
<p>Since the <code>getDirectiveDeclaration</code> method receives not only the name of the directive but also the <code>GraphQLSchema</code> object, it can modify and/or reuse previous declarations found in the schema, as an alternative to returning a totally new <code>GraphQLDirective</code> object. Either way, if the visitor returns a non-null <code>GraphQLDirective</code> from <code>getDirectiveDeclaration</code>, that declaration will be used to check arguments and permissible locations.</p>
<h2 id="What-about-query-directives"><a href="#What-about-query-directives" class="headerlink" title="What about query directives?"></a>What about query directives?</h2><p>As its name suggests, the <code>SchemaDirectiveVisitor</code> abstraction is specifically designed to enable transforming GraphQL schemas based on directives that appear in your SDL text.</p>
<p>While directive syntax can also appear in GraphQL queries sent from the client, implementing query directives would require runtime transformation of query documents. We have deliberately restricted this implementation to transformations that take place at server construction time.</p>
<p>We believe confining this logic to your schema is more sustainable than burdening your clients with it, though you can probably imagine a similar sort of abstraction for implementing query directives. If that possibility becomes a desire that becomes a need for you, let us know, and we may consider supporting query directives in a future version of these tools.</p>

        </div>
      </div>

      <div class="pagination">
        <div class="content-wrapper">
          
          
         
              <a class="link primary prev" href="directives.html">
                <span class="icon-arrow-left-alt"></span>
                <span class="subtitle-pagination">Previous</span>
                Using schema directives
              </a>
         
          
          
           
              <a class="link primary next" href="authentication.html">
                <span class="subtitle-pagination">Next</span>
                Authentication
                  <span class="icon-arrow-right-alt"></span>
              </a>
           
          
        </div>
      </div>

      <div class="github">
        <a class="link tertiary " href="https://github.com/apollographql/apollo-server/tree/master/docs/source/features/creating-directives.md" target="_blank">
          <span class="icon-github"></span>Edit on GitHub</a>
      </div>

      
    </div>

    
    <script type="text/javascript" src="//cdn.jsdelivr.net/npm/prismjs@1.15.0/prism.min.js"></script>
    <script type="text/javascript" src="//cdn.jsdelivr.net/npm/prismjs@1.15.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script type="text/javascript" src="//cdn.jsdelivr.net/npm/prismjs@1.15.0/plugins/line-highlight/prism-line-highlight.min.js"></script>
        <script type="text/javascript" src="//cdn.jsdelivr.net/combine/npm/prismjs@1.15.0/components/prism-bash.min.js,npm/prismjs@1.15.0/components/prism-graphql.min.js,npm/prismjs@1.15.0/components/prism-json.min.js,npm/prismjs@1.15.0/components/prism-jsx.min.js,npm/prismjs@1.15.0/components/prism-less.min.js,npm/prismjs@1.15.0/components/prism-swift.min.js,npm/prismjs@1.15.0/components/prism-typescript.min.js,npm/prismjs@1.15.0/components/prism-yaml.min.js"></script>

    <script type="text/javascript" src="//cdn.jsdelivr.net/npm/smooth-scroll@12.1.5/dist/js/smooth-scroll.min.js"></script>

    <script>
      // Used by the main.js script below.
      docsConfigRoot = '/docs/apollo-server/';
    </script>
    <script src="../script/main.js"></script>

    
      <script type="text/javascript" src="//cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
    
    <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

    <script>
      // nectar ninja
      (function(){
        var handle = '@meteorjs';
        var a = document.createElement('script');
        var m = document.getElementsByTagName('script')[0];
        a.async = 1;
        a.src = 'https://nectar.ninja/api/v1/' + handle.slice(1);
        m.parentNode.insertBefore(a, m);
      })();
    </script>

    

    
      <script>
        
        var analytics;

        <!-- Segment.io -->
        !function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","debug","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t,e){var n=document.createElement("script");n.type="text/javascript";n.async=!0;n.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var o=document.getElementsByTagName("script")[0];o.parentNode.insertBefore(n,o);analytics._loadOptions=e};analytics.SNIPPET_VERSION="4.1.0";
        analytics.load("wgrIo8Bul0Ujl8USETG3DB6hONdy4kTg");
        analytics.page();
        }}();
      </script>
    

    // search box
    
      <script>
        ['desktop'].forEach(function(type) {
          var search = docsearch({
            apiKey: '768e823959d35bbd51e4b2439be13fb7',
            
            
            indexName: 'apollodata',
            inputSelector: '#' + type + '-search-input',
            autocompleteOptions: {
              dropdownMenuContainer: '.wrapper-' + type + '-search-results',
              debug: true
            },
            algoliaOptions: {
              hitsPerPage: 20
            }
          }).autocomplete;

          var sidebar = document.querySelector('.sidebar-content');
          search.on('autocomplete:opened', function() {
            sidebar.classList.add('searching');
          });
          search.on('autocomplete:closed', function() {
            sidebar.classList.remove('searching');
          });
          search.on('autocomplete:updated', function() {
            if (search.val() === '') {
              search.autocomplete.close();
            }
          });
        });
      </script>
    

    

    <script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.3/cookieconsent.min.js"></script>
    <script>
      window.addEventListener('load', function () {
        window.cookieconsent.initialise({
          palette: {
            popup: {
              background: '#555',
            },
            button: {
              text: '#333',
              background: '#CCC',
            },
          },
        })
      });
    </script>
  </body>
</html>
